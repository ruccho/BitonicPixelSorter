#pragma kernel MetaPass
#pragma kernel SortPass
#pragma enable_d3d11_debug_symbols
// #pragma use_dxc // for nsight compatibility (D3D12 required)

#define MAX_THREADS 512 // threads per SM is usually multiple of 512 (NVIDIA). It may maximize occupancy.
#define MAX_SIZE 2048 // due to group shared memory limit

#define MAX_OPS MAX_SIZE / MAX_THREADS

// MetaPass
groupshared uint metaGroupCache[MAX_SIZE * 4];
Texture2D<float4> srcTex;
RWTexture2D<uint> metaTex;

float thresholdMin;
float thresholdMax;

// SortPass
groupshared float4 groupCache[MAX_SIZE];
Texture2D<uint> srcMetaTex;
RWTexture2D<float4> sortTex;

int maxLevels;
bool ordering;

// Common
bool direction;

float brightness(float4 col)
{
    return saturate(0.298912 * col.r + 0.586611 * col.g + 0.114478 * col.b);
}

uint packMetaGroupCache(uint source, bool first, bool left, bool right, int value)
{
    uint packed = asuint(value) & 0x3FFF; // lower 14bit
    packed |= left ? 0x8000 : 0;
    packed |= right ? 0x4000 : 0;
    packed = first ? packed : packed << 16; //shift
    source &= first ? 0xFFFF0000 : 0x0000FFFF;
    source |= packed;
    return source;
}

void unpackMetaGroupCache(uint packed, bool first, out bool left, out bool right, out int value)
{
    packed = first ? packed : packed >> 16;
    left = (packed & 0x8000) != 0;
    right = (packed & 0x4000) != 0;
    
    uint valueSeg = packed & 0x3FFF; //lower 14bit
    bool isNegative = (packed & 0x2000) != 0;
    valueSeg |= isNegative ? 0xFFFFC000 : 0;
    value = asint(valueSeg);
}

// pass to mark pixels to be sorted
[numthreads(32,1,1)]
void MetaPass(uint3 groupId : SV_GroupID,
              uint3 gtid : SV_GroupThreadID)
{
    uint width, height;
    srcTex.GetDimensions(width, height);

    uint size = direction ? width : height;
    uint id = groupId.x * 32 + gtid.x;
    bool metaDirection = id % 2 == 0; // RTL for even thread, LTR for odd thread 
    uint y = id / 2; // two threads per row
    uint groupLocalY = gtid.x / 2;

    int rangeStart = metaDirection ? size : -1;
    uint halfSize = round(size / 8) * 4;

    uint firstHalfSize = metaDirection ? halfSize : (size - halfSize);
    uint cacheLineSize = ceil(size / 4.0);

    uint packedCache = 0;

    {
        for (uint p = 0; p < firstHalfSize; p += 2)
        {
            uint x = metaDirection ? p : (size - p - 1);
            
            uint xMeta = x / 2;
            uint xL = xMeta << 1;
            uint xR = xL + 1;
            uint xFirst = metaDirection ? xL : xR;
            uint xSecond = metaDirection ? xR : xL;

            // position on srcTex
            uint2 posFirst;
            posFirst.x = direction ? xFirst : y;
            posFirst.y = direction ? y : xFirst;
            
            uint2 posSecond;
            posSecond.x = direction ? xSecond : y;
            posSecond.y = direction ? y : xSecond;

            float bFirst = brightness(srcTex[posFirst]);
            bool rangeFirst = xFirst < size && thresholdMin <= bFirst && bFirst <= thresholdMax;

            float bSecond = brightness(srcTex[posSecond]);
            bool rangeSecond = thresholdMin <= bSecond && bSecond <= thresholdMax;

            int rangeStartFirst = metaDirection
                             ? (rangeFirst ? min(rangeStart, (int)xFirst) : size)
                             : (rangeFirst ? max(rangeStart, (int)xFirst) : -1);

            rangeStart = metaDirection
                             ? (rangeSecond ? min(rangeStartFirst, (int)xSecond) : size)
                             : (rangeSecond ? max(rangeStartFirst, (int)xSecond) : -1);

            int rangeStartAny = rangeFirst ? rangeStartFirst : rangeStart;

            //pack into 16-bit
            uint cachePos = groupLocalY * cacheLineSize + x / 4;
            uint cacheFirst = x % 4 < 2;
            bool rangeLeft = metaDirection ? rangeFirst : rangeSecond;
            bool rangeRight = metaDirection ? rangeSecond : rangeFirst;
            packedCache = packMetaGroupCache(packedCache, cacheFirst, rangeLeft, rangeRight, rangeStartAny);

            metaGroupCache[cachePos] = packedCache;
        }
    }

    GroupMemoryBarrierWithGroupSync();

    {
        for (uint p = firstHalfSize; p < size; p += 2)
        {
            uint x = metaDirection ? p : (size - p - 1);

            uint xMeta = x / 2;
            uint xL = xMeta << 1;
            uint xR = xL + 1;
            uint xFirst = metaDirection ? xL : xR;
            uint xSecond = metaDirection ? xR : xL;

            //unpack
            uint cachePos = groupLocalY * cacheLineSize + x / 4;
            bool cacheFirst = x % 4 < 2;
            uint packed = metaGroupCache[cachePos];

            bool rangeLeft;
            bool rangeRight;
            int otherStart;
            
            unpackMetaGroupCache(packed, cacheFirst, rangeLeft, rangeRight, otherStart);

            bool rangeFirst = metaDirection ? rangeLeft : rangeRight;
            bool rangeSecond = metaDirection ? rangeRight : rangeLeft;

            int rangeStartFirst = metaDirection
                             ? (rangeFirst ? min(rangeStart, (int)xFirst) : size)
                             : (rangeFirst ? max(rangeStart, (int)xFirst) : -1);
            
            rangeStart = metaDirection
                             ? (rangeSecond ? min(rangeStartFirst, (int)xSecond) : size)
                             : (rangeSecond ? max(rangeStartFirst, (int)xSecond) : -1);

            int rangeStartAny = rangeFirst ? rangeStartFirst : rangeStart;

            float startL = metaDirection ? rangeStartAny : otherStart;
            float startR = metaDirection ? otherStart : rangeStartAny;
            // position on metaTex
            uint2 pos;
            pos.x = direction ? xMeta : y;
            pos.y = direction ? y : xMeta;

            metaTex[pos] = ((uint)startL << 16) | ((uint)startR & 0xFFFF);
        }
    }
}

[numthreads(MAX_THREADS,1,1)]
void SortPass(uint3 gid : SV_GroupID,
              uint3 gtid : SV_GroupThreadID)
{
    uint ops;
    {
        uint width, height;
        sortTex.GetDimensions(width, height);

        uint size = direction ? width : height;
        uint reducedSize = ceil((float)size / 2);

        ops = ceil((float)reducedSize / MAX_THREADS);

        // cache line to the TGSM
        uint pixelPerThread = ceil((float)size / MAX_THREADS);

        {
            for (uint t = 0; t < pixelPerThread; t++)
            {
                uint x = t * MAX_THREADS + gtid.x;
                uint y = gid.x;
                uint2 id = uint2(x, y);

                uint2 pos;
                pos.x = direction ? id.x : id.y;
                pos.y = direction ? id.y : id.x;

                groupCache[x] = sortTex[pos];
            }
        }
    }

    uint preMeta[MAX_OPS];

    {
        for (uint t = 0; t < ops; t++)
        {
            uint xMeta = (MAX_THREADS * t + gtid.x);
            uint y = gid.x;

            uint xL = xMeta << 1;
            uint xR = xL + 1;

            uint2 id = uint2(xMeta, y);

            uint2 pos;
            pos.x = direction ? id.x : id.y;
            pos.y = direction ? id.y : id.x;

            //get meta
            uint meta = srcMetaTex[pos];
            uint startL = meta >> 16;
            uint startR = meta & 0xFFFF;
            bool useR = (startL % 2) > 0;

            uint x = useR ? xR : xL;

            bool isInRange = (startR - startL > 1) && (x <= startR);

            startL = isInRange ? startL : x;
            startR = isInRange ? startR : x;

            preMeta[t] = (startL << 16) | startR;
        }
    }

    for (uint phase = 0; (phase & 0xFFFF) < (uint)maxLevels; phase++)
    {
        for (phase = (phase << 16) + (phase & 0xFFFF); (uint)(phase >> 16) <= 0x7FFF; phase -= (1 << 16))
        {
            GroupMemoryBarrierWithGroupSync();

            for (uint t = 0; t < ops; t++)
            {
                uint metaPacked = preMeta[t];

                // avoid unnecessary unpacking to reduce register usage
                // uint rangeStart = metaPacked >> 16;
                // uint rangeEnd = metaPacked & 0xFFFF;
                // int comparatorRank = phase >> 16;

                uint x = (MAX_THREADS * t + gtid.x) << 1;

                uint useR = (metaPacked >> 16) & 1;
                uint posInRange = x - (metaPacked >> 16) + useR;
                uint swapIndex = posInRange >> 1;
                uint comparatorSize = 1 << (phase >> 16);
                uint a = (metaPacked >> 16) + (swapIndex & (comparatorSize - 1)) + floor(swapIndex >> (phase >> 16)) * (comparatorSize << 1);

                uint b = a + comparatorSize;

                bool doSwap = b <= (metaPacked & 0xFFFF);
                b = doSwap ? b : a;

                uint block = posInRange >> 1 >> phase;
                uint n = (metaPacked & 0xFFFF) - (metaPacked >> 16) + 1;
                uint endBlock = n >> (phase + 1);
                bool ascPattern = ((endBlock & 1) == 0) == ordering;
                bool asc = ((block & 1) == 0) == ascPattern;

                // compare

                float4 col_a = groupCache[a];
                float4 col_b = groupCache[b];

                float br_a = brightness(col_a);
                float br_b = brightness(col_b);

                bool comp = br_a < br_b;

                float4 left = asc == comp ? col_a : col_b;
                float4 right = asc == comp ? col_b : col_a;

                if (phase == (uint)maxLevels - 1 && (phase >> 16) == 0)
                {
                    uint y = gid.x;
                    uint2 pos_a;
                    pos_a.x = direction ? a : y;
                    pos_a.y = direction ? y : a;

                    uint2 pos_b;
                    pos_b.x = direction ? b : y;
                    pos_b.y = direction ? y : b;

                    sortTex[pos_a] = left;
                    sortTex[pos_b] = right;
                }
                else
                {
                    groupCache[a] = left;
                    groupCache[b] = right;
                }
            }
        }
    }
}
